## Codebase Patterns
- Payload CMS v3 uses the App Router for admin UI, coexisting with pages router
- The @payload-config path alias is required in tsconfig.json for imports
- Use `withPayload()` wrapper in next.config.ts for Payload integration
- Payload admin routes live in `app/(payload)/` route group
- Lookup collections are in `collections/lookups/` with barrel export
- No typecheck script in package.json - use `npx tsc --noEmit` directly
- Custom Payload admin components (like RowLabel) use path strings: '@/components/payload/Component#ExportName'
- Use `useRowLabel` hook from `@payloadcms/ui` in RowLabel client components
- Custom Field components use `useField` and `useFormFields` hooks from `@payloadcms/ui`
- importMap.js is auto-generated on dev server restart when custom components are added
- Cloudinary resource types: 'image' for images, 'raw' for PDFs, 'video' for audio files
- Use admin.custom config to pass custom props to Payload Field components
- Use lib/payload.ts `getPayloadClient()` for server-side Payload Local API access in API routes

---

# Ralph Progress Log
Started: Wed Jan 28 18:47:38 CET 2026
---

## 2026-01-29 - US-001
- What was implemented:
  - Installed Payload CMS packages (payload, @payloadcms/next, @payloadcms/db-postgres, @payloadcms/richtext-lexical)
  - Created payload.config.ts with PostgreSQL/Neon connection using DATABASE_URL env var
  - Created Users collection for admin authentication
  - Added admin routes at /admin via Next.js App Router (app/(payload)/)
  - Configured withPayload in next.config.ts
  - Added @payload-config path alias to tsconfig.json
- Files changed:
  - payload.config.ts (new)
  - collections/Users.ts (new)
  - app/(payload)/admin/[[...segments]]/page.tsx (new)
  - app/(payload)/admin/[[...segments]]/not-found.tsx (new)
  - app/(payload)/admin/importMap.js (new)
  - app/(payload)/api/[[...slug]]/route.ts (new)
  - app/(payload)/api/graphql/route.ts (new)
  - app/(payload)/layout.tsx (new)
  - next.config.ts (modified)
  - tsconfig.json (modified)
  - package.json (modified)
- **Learnings for future iterations:**
  - Payload CMS v3 requires App Router for admin, but can coexist with pages router
  - Admin panel shows "Create first user" setup flow on first run
  - Typecheck passes after setup, no additional type fixes needed
---

## 2026-01-29 - US-002
- What was implemented:
  - Created 5 lookup collections in collections/lookups/: Countries, Languages, Genres, Audiences, Themes
  - Each collection has required, unique name field
  - Languages collection has additional unique code field
  - All collections configured with useAsTitle: 'name' for admin list display
  - Registered all collections in payload.config.ts
- Files changed:
  - collections/lookups/Countries.ts (new)
  - collections/lookups/Languages.ts (new)
  - collections/lookups/Genres.ts (new)
  - collections/lookups/Audiences.ts (new)
  - collections/lookups/Themes.ts (new)
  - collections/lookups/index.ts (new)
  - payload.config.ts (modified)
  - app/(payload)/admin/importMap.js (auto-updated)
- **Learnings for future iterations:**
  - Payload auto-generates importMap.js when collections change - include in commits
  - Use index.ts barrel exports for cleaner imports
  - `defaultColumns` in admin config controls list view columns
---

## 2026-01-29 - US-003
- What was implemented:
  - Created Songs collection with basic fields: title, slug, thumbnailPublicId, difficulty
  - Added many-to-many relationship fields to lookup collections (countries, languages, genres, audiences, themes)
  - Implemented beforeChange hook to auto-generate slug from title on create
  - Configured admin list view with defaultColumns: title, slug, difficulty
  - Registered Songs collection in payload.config.ts
- Files changed:
  - collections/Songs.ts (new)
  - payload.config.ts (modified)
- **Learnings for future iterations:**
  - Use beforeChange hook with operation === 'create' for auto-generation logic
  - Slug generation should normalize diacritics (NFD + regex) for French characters
  - hasMany: true on relationship fields creates many-to-many relationships
---

## 2026-01-29 - US-004
- What was implemented:
  - Added lyrics array field to Songs with language (relationship) and text (textarea) sub-fields
  - Added translations array field to Songs with language (relationship) and text (textarea) sub-fields
  - Created custom RowLabel components for displaying language name as array row label
  - Both array fields have proper labels (Lyric/Lyrics, Translation/Translations)
- Files changed:
  - collections/Songs.ts (modified)
  - components/payload/LanguageRowLabel.tsx (new)
- **Learnings for future iterations:**
  - Payload CMS v3 custom RowLabel components must be client components ('use client')
  - Use path-based string reference for RowLabel: '@/path/to/component#ExportName'
  - Use `useRowLabel` hook from `@payloadcms/ui` to access row data in RowLabel components
  - Custom components for Payload admin should go in components/payload/ directory
---

## 2026-01-29 - US-005
- What was implemented:
  - Added musicSheets array field to Songs with language (relationship) and pdfPublicId (text) sub-fields
  - Added historyDocuments array field to Songs with language (relationship) and pdfPublicId (text) sub-fields
  - Added MusicSheetsRowLabel and HistoryDocumentsRowLabel components for displaying language name as row labels
  - Both array fields use inline editing with proper labels (Music Sheet/Music Sheets, History Document/History Documents)
- Files changed:
  - collections/Songs.ts (modified)
  - components/payload/LanguageRowLabel.tsx (modified)
- **Learnings for future iterations:**
  - Follow established pattern for adding new array fields with language relationships
  - RowLabel components can share the same RowData type when they have identical data structures
  - Group related RowLabel exports in the same file for maintainability
---

## 2026-01-29 - US-006
- What was implemented:
  - Added audioTracks array field to Songs with nested structure
  - trackType select field with options: groupe, violon, chant, guitare, percussion
  - versions nested array with fields: versionId, name, audioPublicId (all required text fields)
  - Created AudioTrackRowLabel.tsx with two components: AudioTrackRowLabel (shows track type label) and AudioVersionRowLabel (shows version name)
  - Admin UI verified in browser showing nested structure with "Add Audio Track" and "Add Version" buttons
- Files changed:
  - collections/Songs.ts (modified)
  - components/payload/AudioTrackRowLabel.tsx (new)
- **Learnings for future iterations:**
  - Nested arrays in Payload work by adding an array field inside another array field
  - Each nested level can have its own RowLabel component for better UX
  - Track type labels should use a mapping object for localized display names
---

## 2026-01-29 - US-007
- What was implemented:
  - Created custom CloudinaryImageField component for Payload admin
  - Component handles file upload to Cloudinary with signed uploads
  - Created API route at /api/cloudinary/sign-upload for generating upload signatures
  - Updated Songs collection to use custom field for thumbnailPublicId
  - Field displays "Upload Image" button, image preview after upload, and "Remove" button
  - Uploads to folder structure: /songs/{slug}/thumbnails/
  - Updated importMap.js to register the custom component
- Files changed:
  - components/payload/CloudinaryImageField.tsx (new)
  - pages/api/cloudinary/sign-upload.ts (new)
  - collections/Songs.ts (modified)
  - app/(payload)/admin/importMap.js (modified)
- **Learnings for future iterations:**
  - Custom Field components need to be registered in importMap.js (Payload auto-generates this on dev server restart)
  - Use `useField` hook from `@payloadcms/ui` to get/set field values in custom components
  - Use `useFormFields` hook to access other form fields (like slug for building folder paths)
  - Cloudinary signed uploads require server-side signature generation for security
  - NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME env var needed for client-side image preview URLs
---

## 2026-01-29 - US-008
- What was implemented:
  - Created CloudinaryPdfField component for PDF file uploads (sheets, history docs)
  - Created CloudinaryAudioField component for audio file uploads with playable preview
  - Updated sign-upload API to support different resource types (image, video, raw)
  - Updated Songs collection to use custom components for pdfPublicId and audioPublicId fields
  - PDF uploads go to /songs/{slug}/sheets/ or /songs/{slug}/history/ based on folderType config
  - Audio uploads go to /songs/{slug}/audio/{track-type}/ dynamically reading trackType from form
  - PDF field shows filename link after upload, Audio field shows audio player preview
- Files changed:
  - components/payload/CloudinaryPdfField.tsx (new)
  - components/payload/CloudinaryAudioField.tsx (new)
  - pages/api/cloudinary/sign-upload.ts (modified)
  - collections/Songs.ts (modified)
  - app/(payload)/admin/importMap.js (modified)
- **Learnings for future iterations:**
  - Cloudinary uses 'raw' resource type for PDFs and 'video' resource type for audio files
  - Custom Field components can read parent array context using path parsing (e.g., audioTracks.0.trackType)
  - Use admin.custom config for passing custom props like folderType to field components
  - Audio uploads need audio/* accept type and render <audio> element for preview
---

## 2026-01-29 - US-009
- What was implemented:
  - Created GET /api/songs API route for listing songs with optional filters
  - Created lib/payload.ts helper to get Payload client instance
  - Implemented query parameter filtering: country, language, genre, audience, theme, difficulty
  - Multiple filters combine with AND logic using Payload's Where type
  - Transforms Payload data to match existing Song interface (nested metadata object)
  - Builds Cloudinary URLs from public_ids for thumbnails, PDFs (raw), and uses placeholder for audio
- Files changed:
  - lib/payload.ts (new)
  - pages/api/songs/index.ts (new)
- **Learnings for future iterations:**
  - Use Payload's Where type for building type-safe query filters
  - depth: 2 in payload.find() is needed to populate nested relationships
  - Cloudinary URLs follow pattern: https://res.cloudinary.com/{cloud_name}/{resource_type}/upload/{public_id}
  - Resource types: 'image' for images, 'raw' for PDFs, 'video' for audio
---

## 2026-01-29 - US-010
- What was implemented:
  - Created GET /api/songs/[slug] route for fetching a single song by slug
  - Returns single song object matching Song interface
  - Returns 404 with error message if song not found
  - Includes all nested data: lyrics, translations, musicSheets, history, audioTracks
  - Transforms relationship IDs to full objects with language names/codes using depth: 2
  - Builds full Cloudinary URLs from public_ids for images (image), PDFs (raw)
- Files changed:
  - pages/api/songs/[slug].ts (new)
- **Learnings for future iterations:**
  - Next.js dynamic API routes use [param] syntax in pages/api folder
  - The transformSong function from /api/songs/index.ts can be reused (consider extracting to shared module if patterns diverge)
  - Query by unique field (slug) with limit: 1 is efficient for single record lookups
---

## 2026-01-29 - US-011
- What was implemented:
  - Created GET /api/songs/[slug]/audio/[trackType]/[versionId] route for audio streaming URLs
  - Returns JSON with Cloudinary streaming URL: { url: string }
  - Validates track type against allowed values: groupe, violon, chant, guitare, percussion
  - Returns 404 for: song not found, track type not found, version not found, audio file missing
  - Uses 'video' resource type for Cloudinary audio URLs (same as upload pattern)
  - Uses depth: 0 for efficiency since no relationship population needed
- Files changed:
  - pages/api/songs/[slug]/audio/[trackType]/[versionId].ts (new)
- **Learnings for future iterations:**
  - Deeply nested dynamic routes in Next.js pages router use nested folder structure: [slug]/audio/[trackType]/[versionId].ts
  - For API routes that only read nested array data, depth: 0 is sufficient and more efficient
  - Audio track data is stored inline in the song document, so no relationship population needed
---

## 2026-01-29 - US-012
- What was implemented:
  - Created GET /api/lookup/[type] route for fetching lookup values (countries, languages, genres, audiences, themes)
  - Returns array of objects with id and name (and code for languages)
  - Results sorted alphabetically by name using Payload's sort parameter
  - Returns 400 with error message for invalid lookup type
  - Uses depth: 0 for efficiency since no relationships in lookup collections
- Files changed:
  - pages/api/lookup/[type].ts (new)
- **Learnings for future iterations:**
  - Use isValidLookupType type guard function to validate enum-like parameters
  - Payload's sort parameter accepts field name directly ('name') for alphabetical sorting
  - Lookup API routes are simpler than songs routes - no transformation needed, just map to response format
---

## 2026-01-29 - US-013
- What was implemented:
  - Created scripts/seed-lookups.ts to populate lookup tables from mockData.ts
  - Extracted unique values: Countries (France, Italie), Languages with codes (fr, en, es, it, de, ar, tr, uk), Genres, Audiences, Themes
  - Script uses Payload Local API (`getPayload`) to create entries
  - Script is idempotent - checks for existing entries before creating
  - Added npm script `db:seed` to package.json: `npx tsx scripts/seed-lookups.ts`
- Files changed:
  - scripts/seed-lookups.ts (new)
  - package.json (modified)
- **Learnings for future iterations:**
  - Use `dotenv/config` import at the top of standalone scripts to load environment variables
  - Import payload.config directly from relative path in scripts (not via @payload-config alias which is Next.js specific)
  - Payload Local API pattern: `await getPayload({ config })` for standalone scripts
---

## 2026-01-29 - US-014
- What was implemented:
  - Created scripts/migrate-songs.ts to import the 3 existing songs from mockData.ts to the database
  - Script pre-fetches all lookup tables (countries, languages, genres, audiences, themes) to build ID maps
  - Creates relationships to lookup tables using ID maps
  - Creates lyrics and translations arrays with language references looked up by name or code
  - Creates music sheets and history documents with placeholder public_ids (songs/{slug}/sheets/score, songs/{slug}/history/history)
  - Creates audio tracks with versions using placeholder public_ids (songs/{slug}/audio/{track}/{versionId})
  - Script is idempotent - checks for existing songs by slug before creating
  - Added npm script `db:migrate-songs` to package.json: `npx tsx scripts/migrate-songs.ts`
- Files changed:
  - scripts/migrate-songs.ts (new)
  - package.json (modified)
- **Learnings for future iterations:**
  - Migration scripts should pre-fetch lookup tables into Maps for efficient ID lookup
  - Language lookup should handle both name and code since mockData uses both
  - Helper function for getLanguageId simplifies code when multiple lookup strategies are needed
  - Placeholder public_ids follow consistent pattern for later Cloudinary uploads
---

## 2026-01-29 - US-015
- What was implemented:
  - Created store/useSongsDataStore.ts Zustand store for fetching songs from API
  - Added state: songs: Song[], currentSong: Song | null, isLoading: boolean, error: string | null
  - Implemented fetchSongs(filters?) action that calls GET /api/songs with optional query params
  - Implemented fetchSongBySlug(slug) action that calls GET /api/songs/[slug]
  - Implemented getAudioUrl(slug, trackType, versionId) action that calls audio API
  - Added helper actions: clearError(), clearCurrentSong()
  - Kept existing useSongStore for UI state (selectedTabs, audio playback, etc)
- Files changed:
  - store/useSongsDataStore.ts (new)
- **Learnings for future iterations:**
  - Zustand stores follow consistent pattern: create<StateInterface>((set, get) => ({ ... }))
  - Separate data fetching stores from UI state stores for cleaner architecture
  - Use URLSearchParams for building query strings with optional filters
  - async actions should set isLoading and error state appropriately
---

## 2026-01-29 - US-016
- What was implemented:
  - Updated Sidebar.tsx to use useSongsDataStore instead of hardcoded songs array
  - Updated pages/song/[slug].tsx to use useSongsDataStore for fetching song data
  - Removed import of getSongBySlug from lib/mockData in song detail page
  - Added loading state with spinner to song detail page
  - Added error state handling to both Sidebar and song detail page
  - Added not-found state to song detail page
  - Both components fetch data on mount/when slug changes
- Files changed:
  - components/Sidebar.tsx (modified)
  - pages/song/[slug].tsx (modified)
- **Learnings for future iterations:**
  - Pages were already using useSongsDataStore; this iteration just needed to commit the existing changes
  - The song list shows empty when database has no songs - this is expected behavior
  - Browser verification confirms pages load correctly with loading/error states
  - Seed scripts (US-013, US-014) must be run to populate the database with actual song data
---

